import React, {Suspense, lazy, useCallback, useEffect, useState} from "react";
import type {ReactNode} from "react";
import {Loading} from "./Loading.js";
import type {PageLayoutProps} from "./PageLayout.js";
import {PageLayout} from "./PageLayout.js";

/**
 * Configuration object provided by the framework build system.
 * Maps to observablehq.config.ts values.
 */
export interface AppConfig {
  title?: string;
  pages: PageLayoutProps["pages"];
  sidebar?: boolean;
  search?: boolean;
  toc?: boolean | {show?: boolean; label?: string};
  header?: ReactNode;
  footer?: ReactNode;
  pager?: boolean;
  base?: string;
}

/**
 * Route definition generated by the build system from file-based routing.
 */
export interface RouteDefinition {
  path: string;
  title?: string;
  /** Dynamic import function for the page component */
  component: () => Promise<{default: React.ComponentType}>;
  /** Previous page in navigation order */
  prev?: {name: string; path: string} | null;
  /** Next page in navigation order */
  next?: {name: string; path: string} | null;
}

export interface AppProps {
  /** App-level configuration */
  config: AppConfig;
  /** Route definitions */
  routes: RouteDefinition[];
  /** Initial path (for SSR/SSG) */
  initialPath?: string;
}

/**
 * Root application component for Observable Framework React apps.
 *
 * Handles:
 * - Client-side routing with lazy-loaded page components
 * - Page layout (sidebar, header, footer, toc)
 * - History-based navigation
 *
 * This replaces the server-rendered full-page HTML with a React SPA.
 */
export function App({config, routes, initialPath}: AppProps) {
  const [currentPath, setCurrentPath] = useState(() => initialPath ?? window.location.pathname);

  // Listen for popstate (browser back/forward)
  useEffect(() => {
    const handlePopState = () => {
      setCurrentPath(window.location.pathname);
    };
    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  // Client-side navigation
  const handleNavigate = useCallback(
    (path: string) => {
      const base = config.base ?? "/";
      const fullPath = path.startsWith("/") ? path : `${base}${path}`;
      window.history.pushState(null, "", fullPath);
      setCurrentPath(fullPath);
      window.scrollTo(0, 0);
    },
    [config.base]
  );

  // Find the matching route
  const route = routes.find((r) => matchPath(r.path, currentPath));
  if (!route) {
    // Try 404 route
    const notFound = routes.find((r) => r.path === "/404");
    if (notFound) {
      return renderRoute(notFound, config, currentPath, handleNavigate);
    }
    return (
      <PageLayout
        siteTitle={config.title}
        sidebar={config.sidebar}
        pages={config.pages}
        path={currentPath}
        search={config.search}
        onNavigate={handleNavigate}
      >
        <h1>Page not found</h1>
        <p>The page {currentPath} does not exist.</p>
      </PageLayout>
    );
  }

  return renderRoute(route, config, currentPath, handleNavigate);
}

function renderRoute(
  route: RouteDefinition,
  config: AppConfig,
  currentPath: string,
  onNavigate: (path: string) => void
) {
  const LazyPage = lazy(route.component);

  return (
    <PageLayout
      title={route.title}
      siteTitle={config.title}
      sidebar={config.sidebar}
      pages={config.pages}
      path={currentPath}
      toc={config.toc}
      header={config.header}
      footer={config.footer}
      prev={route.prev}
      next={route.next}
      search={config.search}
      onNavigate={onNavigate}
    >
      <Suspense fallback={<Loading />}>
        <LazyPage />
      </Suspense>
    </PageLayout>
  );
}

/**
 * Match a route pattern against a path.
 * Supports parameterized routes like /posts/[id].
 */
function matchPath(pattern: string, path: string): boolean {
  // Normalize paths
  const normalizeP = (p: string) => p.replace(/\/$/, "") || "/";
  const np = normalizeP(pattern);
  const npath = normalizeP(path);

  if (np === npath) return true;

  // Check for parameterized segments
  const patternParts = np.split("/");
  const pathParts = npath.split("/");

  if (patternParts.length !== pathParts.length) return false;

  return patternParts.every((part, i) => {
    if (part.startsWith("[") && part.endsWith("]")) return true;
    return part === pathParts[i];
  });
}

/**
 * Extract parameters from a matched route.
 */
export function extractParams(pattern: string, path: string): Record<string, string> {
  const params: Record<string, string> = {};
  const patternParts = pattern.split("/");
  const pathParts = path.split("/");

  patternParts.forEach((part, i) => {
    if (part.startsWith("[") && part.endsWith("]")) {
      const name = part.slice(1, -1);
      params[name] = pathParts[i];
    }
  });

  return params;
}
