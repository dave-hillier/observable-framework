import React, {Suspense, lazy, useCallback, useEffect, useState} from "react";
import type {ReactNode} from "react";
import {Loading} from "./Loading.js";
import type {PageLayoutProps} from "./PageLayout.js";
import {PageLayout} from "./PageLayout.js";

// Cache for lazy-loaded page components to avoid re-creating them on every render.
// Without this, React.lazy() called in render creates a new component identity each
// time, causing unmount/remount and re-triggering Suspense on every state change.
const lazyCache = new Map<() => Promise<{default: React.ComponentType}>, React.LazyExoticComponent<React.ComponentType>>();
function getLazyComponent(loader: () => Promise<{default: React.ComponentType}>): React.LazyExoticComponent<React.ComponentType> {
  let component = lazyCache.get(loader);
  if (!component) {
    component = lazy(loader);
    lazyCache.set(loader, component);
  }
  return component;
}

/**
 * Configuration object provided by the framework build system.
 * Maps to observablehq.config.ts values.
 */
export interface AppConfig {
  title?: string;
  pages: PageLayoutProps["pages"];
  sidebar?: boolean;
  search?: boolean;
  toc?: boolean | {show?: boolean; label?: string};
  header?: ReactNode;
  footer?: ReactNode;
  pager?: boolean;
  base?: string;
}

/**
 * Route definition generated by the build system from file-based routing.
 */
export interface RouteDefinition {
  path: string;
  title?: string;
  /** Dynamic import function for the page component */
  component: () => Promise<{default: React.ComponentType}>;
  /** Previous page in navigation order */
  prev?: {name: string; path: string} | null;
  /** Next page in navigation order */
  next?: {name: string; path: string} | null;
}

export interface AppProps {
  /** App-level configuration */
  config: AppConfig;
  /** Route definitions */
  routes: RouteDefinition[];
  /** Initial path (for SSR/SSG) */
  initialPath?: string;
}

/**
 * Root application component for Observable Framework React apps.
 *
 * Handles:
 * - Client-side routing with lazy-loaded page components
 * - Page layout (sidebar, header, footer, toc)
 * - History-based navigation
 *
 * This replaces the server-rendered full-page HTML with a React SPA.
 */
export function App({config, routes, initialPath}: AppProps) {
  const base = config.base ?? "/";
  const [currentPath, setCurrentPath] = useState(() => initialPath ?? window.location.pathname);

  // Strip the base prefix from a browser path to get the route-relative path.
  // e.g., base="/myapp/", browserPath="/myapp/about" â†’ "/about"
  const stripBase = useCallback(
    (browserPath: string) => {
      if (base !== "/" && browserPath.startsWith(base)) {
        const stripped = browserPath.slice(base.length - 1); // keep leading /
        return stripped || "/";
      }
      return browserPath;
    },
    [base]
  );

  const effectivePath = stripBase(currentPath);

  // Listen for popstate (browser back/forward)
  useEffect(() => {
    const handlePopState = () => {
      setCurrentPath(window.location.pathname);
    };
    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  // Client-side navigation
  const handleNavigate = useCallback(
    (path: string) => {
      const fullPath = path.startsWith("/") ? `${base.replace(/\/$/, "")}${path}` : path;
      window.history.pushState(null, "", fullPath);
      setCurrentPath(fullPath);
      window.scrollTo(0, 0);
    },
    [base]
  );

  // Find the matching route using the base-stripped effective path
  const route = routes.find((r) => matchPath(r.path, effectivePath));
  if (!route) {
    // Try 404 route
    const notFound = routes.find((r) => r.path === "/404");
    if (notFound) {
      return <RouteRenderer route={notFound} config={config} currentPath={effectivePath} onNavigate={handleNavigate} />;
    }
    return (
      <PageLayout
        siteTitle={config.title}
        sidebar={config.sidebar}
        pages={config.pages}
        path={effectivePath}
        search={config.search}
        onNavigate={handleNavigate}
      >
        <h1>Page not found</h1>
        <p>The page {effectivePath} does not exist.</p>
      </PageLayout>
    );
  }

  return <RouteRenderer route={route} config={config} currentPath={effectivePath} onNavigate={handleNavigate} />;
}

function RouteRenderer({
  route,
  config,
  currentPath,
  onNavigate
}: {
  route: RouteDefinition;
  config: AppConfig;
  currentPath: string;
  onNavigate: (path: string) => void;
}) {
  const LazyPage = getLazyComponent(route.component);

  return (
    <PageLayout
      title={route.title}
      siteTitle={config.title}
      sidebar={config.sidebar}
      pages={config.pages}
      path={currentPath}
      toc={config.toc}
      header={config.header}
      footer={config.footer}
      prev={route.prev}
      next={route.next}
      search={config.search}
      onNavigate={onNavigate}
    >
      <Suspense fallback={<Loading />}>
        <LazyPage />
      </Suspense>
    </PageLayout>
  );
}

/**
 * Match a route pattern against a path.
 * Supports parameterized routes like /posts/[id].
 */
function matchPath(pattern: string, path: string): boolean {
  // Normalize paths
  const normalizeP = (p: string) => p.replace(/\/$/, "") || "/";
  const np = normalizeP(pattern);
  const npath = normalizeP(path);

  if (np === npath) return true;

  // Check for parameterized segments
  const patternParts = np.split("/");
  const pathParts = npath.split("/");

  if (patternParts.length !== pathParts.length) return false;

  return patternParts.every((part, i) => {
    if (part.startsWith("[") && part.endsWith("]")) return true;
    return part === pathParts[i];
  });
}

/**
 * Extract parameters from a matched route.
 */
export function extractParams(pattern: string, path: string): Record<string, string> {
  const params: Record<string, string> = {};
  const patternParts = pattern.split("/");
  const pathParts = path.split("/");

  patternParts.forEach((part, i) => {
    if (part.startsWith("[") && part.endsWith("]")) {
      const name = part.slice(1, -1);
      params[name] = pathParts[i];
    }
  });

  return params;
}
